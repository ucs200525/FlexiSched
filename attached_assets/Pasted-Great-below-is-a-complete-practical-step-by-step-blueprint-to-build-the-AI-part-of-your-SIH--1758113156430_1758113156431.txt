Great — below is a complete, practical, step-by-step blueprint to **build the AI part** of your SIH project (Problem ID 25091). It covers problem definition, data model, algorithms, tech stack, detailed CP/ILP formulations, example code snippets (Python + OR-Tools), APIs, testing, scaling, and failure-handling — everything you need to implement the AI server that produces per-student semester timetables aligned with NEP 2020.

I’m giving a single self-contained plan you can follow and code from. I do **not** ask clarifying questions — I assume the inputs/requirements we discussed earlier (slot grid, credits→slots, students, faculty, rooms, labs, preferences).

---

# 1. High-level architecture (AI component only)

* **Input layer (FastAPI)**: receives Admin data, course/faculty/room/student inputs (JSON).
* **Preprocessor**: validates, normalizes, generates base slots grid from admin config.
* **Sectioning engine**: computes number of sections per course (based on student strength & room caps).
* **Scheduler (Core):** OR-Tools CP-SAT model that assigns sections → slots → rooms → faculty, ensuring hard constraints.
* **Student assignment solver:** assigns students to sections (ILP/CP) minimizing preference conflicts.
* **Postprocessor & exporter:** build per-student per-semester timetable JSON, PDF/Excel export.
* **Optional ML module:** demand prediction for elective popularity to pre-create sections.
* **Storage:** MongoDB (or any DB) to store configs, slots, sections, timetables.
* **API endpoints** serve MERN frontend.

---

# 2. Core concepts & data models (MongoDB collection examples)

### `admin_config`

```json
{
  "working_days": ["Tuesday","Wednesday","Thursday","Friday","Saturday"],
  "start_time": "09:00",
  "end_time": "18:00",
  "slot_length_minutes": 55,
  "grace_time_minutes": 5,
  "breaks": [{"type":"lunch","start":"13:00","duration":60}]
}
```

### `slots`

Generated base slots (for each weekday), e.g.:

```json
{ "slot_id": "Tue_A1", "day":"Tuesday","start":"09:00","end":"09:55","type":"theory" }
```

### `courses`

```json
{
 "course_code":"CSE2001","title":"Data Structures","credits":4,"th":3,"lab":2,"is_core":true
}
```

### `rooms`

```json
{"room_id":"R101","capacity":60,"tags":["theory"] }
```

### `faculty`

```json
{"faculty_id":"F001","name":"Dr A","expertise":["CSE2001"],"availability":["Tue_A1","Wed_B1",...],"max_hours_per_week":18}
```

### `students`

```json
{"student_id":"S1001","semester":3,"preferences":{"electives":["PE1","PE3","PE2"]},"enrolled_courses":["CSE2001","MAT1003",...]}
```

### `sections`

After sectioning:

```json
{"section_id":"CSE2001_S1","course":"CSE2001","capacity":60,"type":"theory","faculty":"F001","slots":["Tue_A1","Thu_B1"],"room":"R101"}
```

---

# 3. Step-by-step implementation plan (no time estimates)

## Step 0 — Environment & libs

* Python 3.10+
* FastAPI + Uvicorn
* OR-Tools (`pip install ortools`)
* pandas, numpy, pydantic
* pymongo (or motor) for MongoDB
* scikit-learn / xgboost (optional for demand prediction)
* reportlab / exceljs (or python `openpyxl`/`xlsxwriter`) for exports
* docker for containerization

## Step 1 — Input validation & base slot generation

1. Admin submits `admin_config`.
2. **Generate slot grid** per working day:

   * Compute `slot_block_minutes = slot_length + grace_time`.
   * From `start_time` to `end_time`, subtract breaks; fill with contiguous slot blocks.
   * Name slots: Morning `A1,B1,C1...` and Afternoon `A2,B2...` (use day prefix to avoid symmetry).
3. Save slots collection.

**Edge cases & rules**:

* If breaks cause uneven remaining minutes, prefer reducing a slot (only if admin allows) OR force last slot shorter (notify admin).
* Mark consecutive adjacency (useful for labs).

## Step 2 — Sectioning engine (auto-create sections)

For each `course`:

1. Determine expected students:

   * For core: `students_in_batch`.
   * For elective: use provided demand estimate or predicted demand (or student choices).
2. Compute `sections = ceil(expected / room_capacity_preference)`.
3. Create `section` objects: `capacity` = min(room\_capacity, max\_section\_size) and mark `is_lab` if it needs contiguous slots.
4. For each section create placeholder `slots` length equal to course slots required (credits→slots rules).

**Note:** Prefer fewer, larger sections unless faculty/room constraints push to more.

## Step 3 — Initial feasibility checks

* For each section ensure there exist enough distinct slot patterns & rooms to host them given faculty availability. If not, mark infeasible and include in conflict report.

## Step 4 — Scheduler (OR-Tools CP-SAT) — Full model

### Variables

* `assign_section_slot_room[s, slot, room]` ∈ {0,1}: section s scheduled at slot `slot` using room `room`.

  * For multi-slot course (e.g., 3 slots/week), we create `slots_needed = course_slots` and either:

    * treat `assign_section_slot_room[s, k, slot, room]` where `k` indexes the k-th weekly meeting; or
    * allow `assign_section_slot_weekday...` — simpler is to precompute `slots_needed` separate occurrences.
* `student_assigned[student, section]` ∈ {0,1}: student assigned to section (used in student assignment stage; could be built into a single integrated model but it's heavy).
* `faculty_slot_busy[f, slot]` ∈ {0,1}: helper var.

### Hard constraints (must hold)

1. **Section slot count:** For each section `s`: sum over (slot,room) of `assign_section_slot_room[s,slot,room] == required_meetings(s)`.
2. **Room occupancy:** For each (slot,room): sum over sections `assign_section_slot_room[s,slot,room] <= 1`.
3. **Faculty occupancy:** For each faculty `f` and slot `slot`: sum sections taught by f assigned to slot ≤ 1.
4. **Room capacity vs section capacity:** If `assign_section_slot_room[s,slot,room] == 1` then `room.capacity >= section.capacity` — implement as forbidding assignment to smaller rooms by not creating such variable pairs or by constraint `assign* * room.capacity >= section.capacity` linearized. (Prefer pre-filtering compatible (section,room) pairs.)
5. **Student conflict prevention (during student assignment):** For each student, assigned sections must not have overlapping slots. (Model this in student solver.)
6. **Lab consecutive slots:** For lab meeting that needs consecutive blocks, only allow `(slot, next_slot)` pair assignments where `next_slot` is adjacent. Use adjacency map.
7. **Max faculty hours:** Sum (#slots assigned to faculty) ≤ `max_hours`.

### Soft objectives (optimize)

* Maximize student preference satisfaction (weighted sum of assigned preference ranks).
* Minimize total faculty overload variance (balance load).
* Minimize number of open sections (cost to open sections).
* Maximize room utilization.

Implement objective as weighted linear combination; OR-Tools CP-SAT supports maximizing linear expression.

### Example CP-SAT skeleton (simplified)

```python
from ortools.sat.python import cp_model

model = cp_model.CpModel()
# create variables x_s_slot_room = Bool
# add constraints as above
# objective: maximize sum(student satisfaction * student_assigned) - alpha * #sections_open
solver = cp_model.CpSolver()
solver.parameters.num_search_workers = 8
status = solver.Solve(model)
```

I’ll add a concrete code snippet later in this message.

## Step 5 — Student assignment (two approaches)

**Option A — Integrated model**: include `student_assigned` variables inside the CP model and add constraints tying `student_assigned` to section slot occupancies (very large model, potentially heavy but correct).
**Option B — Two-phase approach (recommended for scalability)**:

1. Run section scheduling (Step 4) → fixed `section → slots, room, faculty`.
2. Build bipartite assignment between `students` and `sections`:

   * Variables `y_student_section`.
   * Hard: `sum_sections_for_course(student, course) == 1` for each required course.
   * Hard: `for overlapping sections (same slot), sum y <= 1`.
   * Capacity constraints: `sum_students_y(section) <= section.capacity`.
   * Objective: maximize preference satisfaction.
   * Solve with CP-SAT or max-flow / Hungarian variant (but with capacity and conflict constraints CP-SAT easier).

## Step 6 — Conflict handling & suggestions

* If result infeasible (no solution):

  * Generate conflict report listing impossible items (e.g., too many students vs rooms).
  * Use heuristics to propose remedies:

    * Increase number of sections for affected courses.
    * Suggest moving certain courses into alternative slots (swap).
    * Suggest changing faculty availability or room allocation.
  * Provide interactive scenario simulation API so Admin can accept suggestions and re-run solver.

## Step 7 — Optional ML: elective demand prediction

* Features: past enrollment counts, course popularity, related courses, semester, batch size, time-of-day preference, faculty rating.
* Model: simple gradient-boosted tree (XGBoost) or logistic regression to predict expected enrollment per elective.
* Use predictions to pre-create sections (reduce re-runs).

## Step 8 — API design (FastAPI) — key endpoints

* `POST /api/admin/config` — save admin config.
* `POST /api/generate_slots` — generate slot grid from config.
* `POST /api/sectioning` — create sections from courses + strengths.
* `POST /api/generate_timetable` — call scheduler; returns timetable JSON and conflict report.
* `POST /api/assign_students` — run student assignment solver.
* `GET /api/timetable/student/{id}` — get per-student timetable.
* `POST /api/simulate` — scenario simulation (lock/modify slots & re-run).
* `POST /api/predict_demand` — ML demand prediction.

## Step 9 — Outputs & exports

* Per-student JSON timetable: list of slots with course, section, faculty, room.
* Per-faculty timetable.
* College master timetable.
* Export to PDF and Excel.

---

# 4. Concrete CP-SAT code snippets (practical)

### 4.1 Helper: generate slot adjacency (for labs)

```python
def build_adjacency(slots):
    # slots sorted by day then start time
    # return mapping slot -> next_slot if contiguous (end == next.start - grace)
    adjacency = {}
    # implement sorting and mapping
    return adjacency
```

### 4.2 Core schedule model (simplified but practical)

```python
from ortools.sat.python import cp_model

def schedule_sections(sections, rooms, faculty, slots, time_limit_seconds=30):
    model = cp_model.CpModel()
    # Precompute compatible (section,room) pairs where room.capacity >= section.capacity and tags match
    compat = {}
    for s in sections:
        compat[s['id']] = [r['id'] for r in rooms if r['capacity'] >= s['capacity'] and set(s.get('tags',[])).issubset(set(r.get('tags',[])))]

    # Variables: x[s][slot][r] bool
    x = {}
    for s in sections:
        x[s['id']] = {}
        for slot in slots:
            x[s['id']][slot['id']] = {}
            for r in compat[s['id']]:
                x[s['id']][slot['id']][r] = model.NewBoolVar(f"x_{s['id']}_{slot['id']}_{r}")

    # Constraint: each section must get required number of meetings (meetings = slots_required)
    for s in sections:
        model.Add(sum(x[s['id']][slot['id']][r] 
                      for slot in slots
                      for r in compat[s['id']]) == s['slots_required'])

    # Room occupancy
    for slot in slots:
        for r in [room['id'] for room in rooms]:
            model.Add(sum(x[s['id']][slot['id']].get(r, 0) 
                          for s in sections) <= 1)

    # Faculty occupancy: map course->faculty
    for f in faculty:
        for slot in slots:
            model.Add(sum(x[s['id']][slot['id']][r] 
                          for s in sections if s.get('faculty')==f['id']
                          for r in compat[s['id']]) <= 1)

    # Labs: if section needs consecutive slots, ensure its assigned slots are an allowed consecutive set
    # Implement by checking adjacency and creating helper constraints (omitted here for brevity)

    # Objective (example: minimize number of different rooms used)
    obj_vars = []
    for s in sections:
        for slot in slots:
            for r in compat[s['id']]:
                obj_vars.append(x[s['id']][slot['id']][r])
    model.Minimize(sum(obj_vars))

    solver = cp_model.CpSolver()
    solver.parameters.max_time_in_seconds = time_limit_seconds
    solver.parameters.num_search_workers = 8
    status = solver.Solve(model)

    if status in (cp_model.OPTIMAL, cp_model.FEASIBLE):
        schedule = []
        for s in sections:
            for slot in slots:
                for r in compat[s['id']]:
                    if solver.Value(x[s['id']][slot['id']][r]) == 1:
                        schedule.append({"section": s['id'], "slot": slot['id'], "room": r})
        return schedule
    else:
        return {"infeasible": True}
```

> This is a simplified but practical starting point. For production add lab-consecutiveness constraints, prefilter incompatible pairs, and integrate student assignment.

### 4.3 Student assignment (two-phase) CP model sketch

```python
def assign_students_to_sections(students, sections, section_slots):
    model = cp_model.CpModel()
    y = {}
    for stu in students:
        y[stu['id']] = {}
        for s in sections:
            # only allow assignment to sections of the same course student enrolled in OR to electives if in preference list
            y[stu['id']][s['id']] = model.NewBoolVar(f"y_{stu['id']}_{s['id']}")

    # For each student and course: sum assigned sections of that course == 1
    for stu in students:
        for course in stu['enrolled_courses']:
            model.Add(sum(y[stu['id']][s['id']] for s in sections if s['course'] == course) == 1)

    # Capacity constraint
    for s in sections:
        model.Add(sum(y[stu['id']][s['id']] for stu in students) <= s['capacity'])

    # Conflict: For any pair of sections that overlap in slot, a student can't be assigned to both
    for stu in students:
        overlapping_pairs = find_overlapping_section_pairs(section_slots)
        for (s1, s2) in overlapping_pairs:
            model.Add(y[stu['id']][s1] + y[stu['id']][s2] <= 1)

    # Objective: maximize preference satisfaction (map preferences to scores)
    obj_terms = []
    for stu in students:
        for s in sections:
            score = preference_score(stu, s)  # e.g., 100 for top choice, 50 for 2nd...
            obj_terms.append(y[stu['id']][s['id']] * score)
    model.Maximize(sum(obj_terms))

    solver = cp_model.CpSolver()
    status = solver.Solve(model)
    # read assignments...
```

---

# 5. Evaluation metrics & reporting

* **Feasibility**: number of hard-constraint violations (should be zero).
* **Student satisfaction**: % of students assigned to 1st, 2nd, 3rd choices.
* **Faculty load variance**: standard deviation of hours assigned vs target.
* **Room utilization**: average % occupancy.
* **Solver performance**: runtime, nodes explored — set `max_time_in_seconds`.
* **Conflict count**: number of students left unassigned (should be minimized).

Log all metrics on each run and expose them via API.

---

# 6. Failure handling & fallback strategies

If solver returns infeasible or poor satisfaction:

1. Automatically run heuristics:

   * Increase sections for the most congested courses.
   * Rebalance capacities across rooms (use larger rooms).
   * Relax soft constraints (allow a limited faculty double-slot once).
2. Provide admin UI suggestions with estimated benefit and let admin accept & re-run.
3. For urgent runs: run greedy heuristic to produce a feasible timetable (not optimal) — e.g., schedule cores first, then assign students to remaining slots using first-fit decreasing by popularity.

---

# 7. Testing strategy

* **Unit tests**:

  * Slot generation edge cases (breaks, odd minutes).
  * Section counting (`ceil(...)`) correctness.
  * Lab adjacency detection.
* **Integration tests**:

  * Full run on synthetic data sets (small, medium, large).
  * Validate no student/faculty/room clashes.
* **Stress tests**:

  * Increase students to 5× and measure runtime.
* **Acceptance tests**:

  * Use real semester data (if available) and compare to manual timetable quality (satisfaction and clashes).

---

# 8. Scaling & production tips

* Use `solver.parameters.max_time_in_seconds` to bound runtime. If problem large, two-phase approach scales better.
* Pre-filter incompatible (section,room) pairs to reduce variables.
* Use symmetry breaking (e.g., force lexicographic order of section IDs to remove identical solutions).
* Run heavy solves on a dedicated VM; use multiple threads.
* Cache results for repeated re-runs; make deltas only re-solve changed parts.

---

# 9. Deliverables for SIH submission

* Working FastAPI AI server (containerized) with endpoints above.
* MERN frontend hooks (sample requests) and sample per-student timetable view.
* Documentation: README + architecture diagram + sample JSON payloads.
* Exports: sample PDF/Excel timetables.
* Demo video walkthrough (use your provided YouTube link style).
* Test dataset and results (metrics dashboards).

---

# 10. What I included (practical checklist you can follow now)

1. Input schemas and DB collections.
2. Slot generator algorithm (uses admin config).
3. Sectioning logic (ceil of students/capacity).
4. CP-SAT model structure + code skeletons for scheduling & student assignment.
5. ML suggestion for demand prediction.
6. API endpoints for integration.
7. Evaluation metrics & fallback strategies.
8. Testing & production notes.

---

If you want, I’ll now:

* produce a **complete working FastAPI + OR-Tools codebase skeleton** (files: `app/main.py`, `ai/scheduler.py`, `ai/sectioner.py`, `models/*.py`, tests), with realistic sample data you can run locally, **including** the full CP-SAT model with lab-consecutive-slot constraints and a sample dataset.

(If you want that, tell me “generate codebase” — I’ll output the code files inline.)
